// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: address.sql

package dbgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createAddress = `-- name: CreateAddress :one
INSERT INTO addresses (
    user_id, label, recipient_name, recipient_phone,
    street, subdistrict, district, city, province, postal_code, is_primary
) VALUES (
    $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11
)
RETURNING id, user_id, label, recipient_name, recipient_phone, street, subdistrict, district, city, province, postal_code, is_primary, created_at, updated_at, deleted_at
`

type CreateAddressParams struct {
	UserID         uuid.UUID      `json:"user_id"`
	Label          string         `json:"label"`
	RecipientName  string         `json:"recipient_name"`
	RecipientPhone string         `json:"recipient_phone"`
	Street         string         `json:"street"`
	Subdistrict    sql.NullString `json:"subdistrict"`
	District       sql.NullString `json:"district"`
	City           sql.NullString `json:"city"`
	Province       sql.NullString `json:"province"`
	PostalCode     sql.NullString `json:"postal_code"`
	IsPrimary      bool           `json:"is_primary"`
}

func (q *Queries) CreateAddress(ctx context.Context, arg CreateAddressParams) (Address, error) {
	row := q.queryRow(ctx, q.createAddressStmt, createAddress,
		arg.UserID,
		arg.Label,
		arg.RecipientName,
		arg.RecipientPhone,
		arg.Street,
		arg.Subdistrict,
		arg.District,
		arg.City,
		arg.Province,
		arg.PostalCode,
		arg.IsPrimary,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Label,
		&i.RecipientName,
		&i.RecipientPhone,
		&i.Street,
		&i.Subdistrict,
		&i.District,
		&i.City,
		&i.Province,
		&i.PostalCode,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listAddressesAdmin = `-- name: ListAddressesAdmin :many
SELECT a.id, a.user_id, a.label, a.recipient_name, a.recipient_phone, a.street, a.subdistrict, a.district, a.city, a.province, a.postal_code, a.is_primary, a.created_at, a.updated_at, a.deleted_at, u.email, count(*) OVER() AS total_count
FROM addresses a
JOIN users u ON u.id = a.user_id
WHERE a.deleted_at IS NULL
ORDER BY a.created_at DESC
LIMIT $1 OFFSET $2
`

type ListAddressesAdminParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAddressesAdminRow struct {
	ID             uuid.UUID      `json:"id"`
	UserID         uuid.UUID      `json:"user_id"`
	Label          string         `json:"label"`
	RecipientName  string         `json:"recipient_name"`
	RecipientPhone string         `json:"recipient_phone"`
	Street         string         `json:"street"`
	Subdistrict    sql.NullString `json:"subdistrict"`
	District       sql.NullString `json:"district"`
	City           sql.NullString `json:"city"`
	Province       sql.NullString `json:"province"`
	PostalCode     sql.NullString `json:"postal_code"`
	IsPrimary      bool           `json:"is_primary"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
	Email          string         `json:"email"`
	TotalCount     int64          `json:"total_count"`
}

func (q *Queries) ListAddressesAdmin(ctx context.Context, arg ListAddressesAdminParams) ([]ListAddressesAdminRow, error) {
	rows, err := q.query(ctx, q.listAddressesAdminStmt, listAddressesAdmin, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAddressesAdminRow
	for rows.Next() {
		var i ListAddressesAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Label,
			&i.RecipientName,
			&i.RecipientPhone,
			&i.Street,
			&i.Subdistrict,
			&i.District,
			&i.City,
			&i.Province,
			&i.PostalCode,
			&i.IsPrimary,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Email,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAddressesByUser = `-- name: ListAddressesByUser :many
SELECT id, user_id, label, recipient_name, recipient_phone, street, subdistrict, district, city, province, postal_code, is_primary, created_at, updated_at, deleted_at, count(*) OVER() AS total_count
FROM addresses
WHERE user_id = $1
  AND deleted_at IS NULL
ORDER BY is_primary DESC, created_at DESC
`

type ListAddressesByUserRow struct {
	ID             uuid.UUID      `json:"id"`
	UserID         uuid.UUID      `json:"user_id"`
	Label          string         `json:"label"`
	RecipientName  string         `json:"recipient_name"`
	RecipientPhone string         `json:"recipient_phone"`
	Street         string         `json:"street"`
	Subdistrict    sql.NullString `json:"subdistrict"`
	District       sql.NullString `json:"district"`
	City           sql.NullString `json:"city"`
	Province       sql.NullString `json:"province"`
	PostalCode     sql.NullString `json:"postal_code"`
	IsPrimary      bool           `json:"is_primary"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
	TotalCount     int64          `json:"total_count"`
}

func (q *Queries) ListAddressesByUser(ctx context.Context, userID uuid.UUID) ([]ListAddressesByUserRow, error) {
	rows, err := q.query(ctx, q.listAddressesByUserStmt, listAddressesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAddressesByUserRow
	for rows.Next() {
		var i ListAddressesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Label,
			&i.RecipientName,
			&i.RecipientPhone,
			&i.Street,
			&i.Subdistrict,
			&i.District,
			&i.City,
			&i.Province,
			&i.PostalCode,
			&i.IsPrimary,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteAddress = `-- name: SoftDeleteAddress :exec
UPDATE addresses
SET deleted_at = NOW()
WHERE id = $1
  AND user_id = $2
  AND deleted_at IS NULL
`

type SoftDeleteAddressParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) SoftDeleteAddress(ctx context.Context, arg SoftDeleteAddressParams) error {
	_, err := q.exec(ctx, q.softDeleteAddressStmt, softDeleteAddress, arg.ID, arg.UserID)
	return err
}

const unsetPrimaryAddressByUser = `-- name: UnsetPrimaryAddressByUser :exec
UPDATE addresses
SET is_primary = FALSE,
    updated_at = NOW()
WHERE user_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) UnsetPrimaryAddressByUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.exec(ctx, q.unsetPrimaryAddressByUserStmt, unsetPrimaryAddressByUser, userID)
	return err
}

const updateAddress = `-- name: UpdateAddress :one
UPDATE addresses
SET label = $2,
    recipient_name = $3,
    recipient_phone = $4,
    street = $5,
    subdistrict = $6,
    district = $7,
    city = $8,
    province = $9,
    postal_code = $10,
    is_primary = $11,
    updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
RETURNING id, user_id, label, recipient_name, recipient_phone, street, subdistrict, district, city, province, postal_code, is_primary, created_at, updated_at, deleted_at
`

type UpdateAddressParams struct {
	ID             uuid.UUID      `json:"id"`
	Label          string         `json:"label"`
	RecipientName  string         `json:"recipient_name"`
	RecipientPhone string         `json:"recipient_phone"`
	Street         string         `json:"street"`
	Subdistrict    sql.NullString `json:"subdistrict"`
	District       sql.NullString `json:"district"`
	City           sql.NullString `json:"city"`
	Province       sql.NullString `json:"province"`
	PostalCode     sql.NullString `json:"postal_code"`
	IsPrimary      bool           `json:"is_primary"`
}

func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) (Address, error) {
	row := q.queryRow(ctx, q.updateAddressStmt, updateAddress,
		arg.ID,
		arg.Label,
		arg.RecipientName,
		arg.RecipientPhone,
		arg.Street,
		arg.Subdistrict,
		arg.District,
		arg.City,
		arg.Province,
		arg.PostalCode,
		arg.IsPrimary,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Label,
		&i.RecipientName,
		&i.RecipientPhone,
		&i.Street,
		&i.Subdistrict,
		&i.District,
		&i.City,
		&i.Province,
		&i.PostalCode,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
