// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reviews.sql

package dbgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkReviewExists = `-- name: CheckReviewExists :one
SELECT EXISTS(
    SELECT 1 FROM reviews
    WHERE user_id = $1 AND product_id = $2 AND deleted_at IS NULL
) AS exists
`

type CheckReviewExistsParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProductID uuid.UUID `json:"product_id"`
}

func (q *Queries) CheckReviewExists(ctx context.Context, arg CheckReviewExistsParams) (bool, error) {
	row := q.queryRow(ctx, q.checkReviewExistsStmt, checkReviewExists, arg.UserID, arg.ProductID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserPurchasedProduct = `-- name: CheckUserPurchasedProduct :one
SELECT EXISTS(
    SELECT 1 FROM orders o
    JOIN order_items oi ON o.id = oi.order_id
    WHERE o.user_id = $1 
    AND oi.product_id = $2 
    AND o.status = 'COMPLETED'
    AND o.deleted_at IS NULL
) AS exists
`

type CheckUserPurchasedProductParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProductID uuid.UUID `json:"product_id"`
}

func (q *Queries) CheckUserPurchasedProduct(ctx context.Context, arg CheckUserPurchasedProductParams) (bool, error) {
	row := q.queryRow(ctx, q.checkUserPurchasedProductStmt, checkUserPurchasedProduct, arg.UserID, arg.ProductID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countReviewsByProductID = `-- name: CountReviewsByProductID :one
SELECT COUNT(*) FROM reviews
WHERE product_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountReviewsByProductID(ctx context.Context, productID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.countReviewsByProductIDStmt, countReviewsByProductID, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReviewsByUserID = `-- name: CountReviewsByUserID :one
SELECT COUNT(*) FROM reviews
WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountReviewsByUserID(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.countReviewsByUserIDStmt, countReviewsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReview = `-- name: CreateReview :one
INSERT INTO reviews (user_id, product_id, order_id, rating, comment, is_verified_purchase)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, product_id, order_id, rating, comment, is_verified_purchase, created_at, updated_at, deleted_at
`

type CreateReviewParams struct {
	UserID             uuid.UUID `json:"user_id"`
	ProductID          uuid.UUID `json:"product_id"`
	OrderID            uuid.UUID `json:"order_id"`
	Rating             int32     `json:"rating"`
	Comment            string    `json:"comment"`
	IsVerifiedPurchase bool      `json:"is_verified_purchase"`
}

func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) (Review, error) {
	row := q.queryRow(ctx, q.createReviewStmt, createReview,
		arg.UserID,
		arg.ProductID,
		arg.OrderID,
		arg.Rating,
		arg.Comment,
		arg.IsVerifiedPurchase,
	)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.OrderID,
		&i.Rating,
		&i.Comment,
		&i.IsVerifiedPurchase,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteReview = `-- name: DeleteReview :exec
UPDATE reviews
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteReview(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteReviewStmt, deleteReview, id)
	return err
}

const getAverageRatingByProductID = `-- name: GetAverageRatingByProductID :one
SELECT COALESCE(AVG(rating), 0) as average_rating
FROM reviews
WHERE product_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetAverageRatingByProductID(ctx context.Context, productID uuid.UUID) (interface{}, error) {
	row := q.queryRow(ctx, q.getAverageRatingByProductIDStmt, getAverageRatingByProductID, productID)
	var average_rating interface{}
	err := row.Scan(&average_rating)
	return average_rating, err
}

const getCompletedOrderForReview = `-- name: GetCompletedOrderForReview :one
SELECT o.id
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
WHERE o.user_id = $1 
AND oi.product_id = $2 
AND o.status = 'COMPLETED'
AND o.deleted_at IS NULL
ORDER BY o.completed_at DESC
LIMIT 1
`

type GetCompletedOrderForReviewParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProductID uuid.UUID `json:"product_id"`
}

func (q *Queries) GetCompletedOrderForReview(ctx context.Context, arg GetCompletedOrderForReviewParams) (uuid.UUID, error) {
	row := q.queryRow(ctx, q.getCompletedOrderForReviewStmt, getCompletedOrderForReview, arg.UserID, arg.ProductID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getReviewByID = `-- name: GetReviewByID :one
SELECT r.id, r.user_id, r.product_id, r.order_id, r.rating, r.comment, r.is_verified_purchase, r.created_at, r.updated_at, r.deleted_at, u.first_name as user_name, u.email as user_email
FROM reviews r
JOIN users u ON r.user_id = u.id
WHERE r.id = $1 AND r.deleted_at IS NULL
LIMIT 1
`

type GetReviewByIDRow struct {
	ID                 uuid.UUID    `json:"id"`
	UserID             uuid.UUID    `json:"user_id"`
	ProductID          uuid.UUID    `json:"product_id"`
	OrderID            uuid.UUID    `json:"order_id"`
	Rating             int32        `json:"rating"`
	Comment            string       `json:"comment"`
	IsVerifiedPurchase bool         `json:"is_verified_purchase"`
	CreatedAt          time.Time    `json:"created_at"`
	UpdatedAt          time.Time    `json:"updated_at"`
	DeletedAt          sql.NullTime `json:"deleted_at"`
	UserName           string       `json:"user_name"`
	UserEmail          string       `json:"user_email"`
}

func (q *Queries) GetReviewByID(ctx context.Context, id uuid.UUID) (GetReviewByIDRow, error) {
	row := q.queryRow(ctx, q.getReviewByIDStmt, getReviewByID, id)
	var i GetReviewByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.OrderID,
		&i.Rating,
		&i.Comment,
		&i.IsVerifiedPurchase,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserName,
		&i.UserEmail,
	)
	return i, err
}

const getReviewsByProductID = `-- name: GetReviewsByProductID :many
SELECT r.id, r.user_id, r.product_id, r.order_id, r.rating, r.comment, r.is_verified_purchase, r.created_at, r.updated_at, r.deleted_at, u.first_name as user_name
FROM reviews r
JOIN users u ON r.user_id = u.id
WHERE r.product_id = $1 AND r.deleted_at IS NULL
ORDER BY r.created_at DESC
LIMIT $2 OFFSET $3
`

type GetReviewsByProductIDParams struct {
	ProductID uuid.UUID `json:"product_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

type GetReviewsByProductIDRow struct {
	ID                 uuid.UUID    `json:"id"`
	UserID             uuid.UUID    `json:"user_id"`
	ProductID          uuid.UUID    `json:"product_id"`
	OrderID            uuid.UUID    `json:"order_id"`
	Rating             int32        `json:"rating"`
	Comment            string       `json:"comment"`
	IsVerifiedPurchase bool         `json:"is_verified_purchase"`
	CreatedAt          time.Time    `json:"created_at"`
	UpdatedAt          time.Time    `json:"updated_at"`
	DeletedAt          sql.NullTime `json:"deleted_at"`
	UserName           string       `json:"user_name"`
}

func (q *Queries) GetReviewsByProductID(ctx context.Context, arg GetReviewsByProductIDParams) ([]GetReviewsByProductIDRow, error) {
	rows, err := q.query(ctx, q.getReviewsByProductIDStmt, getReviewsByProductID, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByProductIDRow
	for rows.Next() {
		var i GetReviewsByProductIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductID,
			&i.OrderID,
			&i.Rating,
			&i.Comment,
			&i.IsVerifiedPurchase,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByUserID = `-- name: GetReviewsByUserID :many
SELECT r.id, r.user_id, r.product_id, r.order_id, r.rating, r.comment, r.is_verified_purchase, r.created_at, r.updated_at, r.deleted_at, p.name as product_name, p.slug as product_slug
FROM reviews r
JOIN products p ON r.product_id = p.id
WHERE r.user_id = $1 AND r.deleted_at IS NULL
ORDER BY r.created_at DESC
LIMIT $2 OFFSET $3
`

type GetReviewsByUserIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetReviewsByUserIDRow struct {
	ID                 uuid.UUID    `json:"id"`
	UserID             uuid.UUID    `json:"user_id"`
	ProductID          uuid.UUID    `json:"product_id"`
	OrderID            uuid.UUID    `json:"order_id"`
	Rating             int32        `json:"rating"`
	Comment            string       `json:"comment"`
	IsVerifiedPurchase bool         `json:"is_verified_purchase"`
	CreatedAt          time.Time    `json:"created_at"`
	UpdatedAt          time.Time    `json:"updated_at"`
	DeletedAt          sql.NullTime `json:"deleted_at"`
	ProductName        string       `json:"product_name"`
	ProductSlug        string       `json:"product_slug"`
}

func (q *Queries) GetReviewsByUserID(ctx context.Context, arg GetReviewsByUserIDParams) ([]GetReviewsByUserIDRow, error) {
	rows, err := q.query(ctx, q.getReviewsByUserIDStmt, getReviewsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByUserIDRow
	for rows.Next() {
		var i GetReviewsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProductID,
			&i.OrderID,
			&i.Rating,
			&i.Comment,
			&i.IsVerifiedPurchase,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProductName,
			&i.ProductSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReview = `-- name: UpdateReview :one
UPDATE reviews
SET rating = $2,
    comment = $3,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, user_id, product_id, order_id, rating, comment, is_verified_purchase, created_at, updated_at, deleted_at
`

type UpdateReviewParams struct {
	ID      uuid.UUID `json:"id"`
	Rating  int32     `json:"rating"`
	Comment string    `json:"comment"`
}

func (q *Queries) UpdateReview(ctx context.Context, arg UpdateReviewParams) (Review, error) {
	row := q.queryRow(ctx, q.updateReviewStmt, updateReview, arg.ID, arg.Rating, arg.Comment)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.OrderID,
		&i.Rating,
		&i.Comment,
		&i.IsVerifiedPurchase,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
